import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { FirebaseService } from '../../core/services/firebase.service';
import { NotificationService } from '../../core/services/notification.service';
import { HeaderComponent } from '../../shared/components/header/header.component';
import { StatCardComponent } from '../../shared/components/stat-card/stat-card.component';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, RouterModule, HeaderComponent, StatCardComponent],
  templateUrl: './dashboard.component.html',
  styleUrls: ['./dashboard.component.scss']
})
export class DashboardComponent implements OnInit, OnDestroy {
  
  // KPIs principales
  totalCotizaciones: number = 0;
  valorTotalCotizaciones: number = 0;
  totalContratosCerrados: number = 0;
  tasaConversion: number = 0;
  
  // M√©tricas Detalladas
  servicioMasVendido: string = 'Consultor√≠a IT';
  valorPromedio: number = 423272;
  tiempoPromedio: string = '5 d√≠as';
  clientesActivos: number = 45;
  clienteTop: string = 'Empresa ABC';
  tasaRetencion: number = 78;
  eficiencia: number = 13;
  velocidadPromedio: string = '3.2 d√≠as promedio';
  tasaCrecimiento: number = 15;
  
  // Datos para gr√°ficos
  rendimientoUsuarios: any[] = [];
  tendenciaVentas: any[] = [];
  embudoVentas: any[] = [];
  
  // Subscripciones
  private subscriptions: any[] = [];
  
  constructor(
    private firebaseService: FirebaseService,
    private notificationService: NotificationService
  ) {
    console.log('üöÄ DashboardComponent: Inicializando dashboard');
  }
  
  ngOnInit(): void {
    console.log('üìä DashboardComponent: Cargando datos del dashboard');
    this.cargarDatosDashboard();
  }
  
  ngOnDestroy(): void {
    console.log('üßπ DashboardComponent: Limpiando recursos');
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }
  
  /**
   * Carga los datos de Firebase y procesa las m√©tricas
   */
  private cargarDatosDashboard(): void {
    console.log('üìà DashboardComponent: Suscribi√©ndose a datos de Firebase');
    
    // Suscribirse a cotizaciones
    const cotizacionesSub = this.firebaseService.getCotizaciones().subscribe({
      next: (cotizaciones) => {
        console.log('üìã DashboardComponent: Cotizaciones cargadas:', cotizaciones.length);
        this.procesarCotizaciones(cotizaciones);
        this.procesarRendimientoUsuarios(cotizaciones);
        this.procesarTendenciaVentas(cotizaciones);
        this.procesarEmbudoVentas(cotizaciones);
      },
      error: (error) => {
        console.error('‚ùå DashboardComponent: Error al cargar cotizaciones:', error);
        this.notificationService.showError('Error al cargar datos de cotizaciones');
      }
    });
    
    // Suscribirse a contratos
    const contratosSub = this.firebaseService.getContratos().subscribe({
      next: (contratos) => {
        console.log('üìÑ DashboardComponent: Contratos cargados:', contratos.length);
        this.procesarContratos(contratos);
      },
      error: (error) => {
        console.error('‚ùå DashboardComponent: Error al cargar contratos:', error);
        this.notificationService.showError('Error al cargar datos de contratos');
      }
    });
    
    this.subscriptions.push(cotizacionesSub, contratosSub);
  }
  
  /**
   * Procesa los datos de cotizaciones para calcular KPIs
   */
  private procesarCotizaciones(cotizaciones: any[]): void {
    if (!cotizaciones || cotizaciones.length === 0) {
      console.log('üìä DashboardComponent: No hay cotizaciones para procesar');
      return;
    }
    
    // Calcular KPIs b√°sicos
    this.totalCotizaciones = cotizaciones.length;
    this.valorTotalCotizaciones = cotizaciones.reduce((total, cotizacion) => {
      return total + (cotizacion.valorTotal || 0);
    }, 0);
    
    // Calcular valor promedio
    this.valorPromedio = this.totalCotizaciones > 0 ? 
      this.valorTotalCotizaciones / this.totalCotizaciones : 0;
    
    // Calcular clientes activos (√∫nicos)
    const clientesUnicos = new Set(cotizaciones.map(c => c.nombre || c.email));
    this.clientesActivos = clientesUnicos.size;
    
    // Calcular cliente top (que genera m√°s valor)
    const clientesPorValor = cotizaciones.reduce((acc, cotizacion) => {
      const cliente = cotizacion.nombre || cotizacion.email || 'Cliente';
      acc[cliente] = (acc[cliente] || 0) + (cotizacion.valorTotal || 0);
      return acc;
    }, {} as any);
    
    const clienteTop = Object.entries(clientesPorValor)
      .sort(([,a], [,b]) => (b as number) - (a as number))[0];
    this.clienteTop = clienteTop ? clienteTop[0] as string : 'N/A';
    
    console.log('üìä DashboardComponent: KPIs de cotizaciones calculados:', {
      total: this.totalCotizaciones,
      valorTotal: this.valorTotalCotizaciones,
      valorPromedio: this.valorPromedio,
      clientesActivos: this.clientesActivos,
      clienteTop: this.clienteTop
    });
  }
  
  /**
   * Procesa los datos de contratos para calcular m√©tricas adicionales
   */
  private procesarContratos(contratos: any[]): void {
    if (!contratos || contratos.length === 0) {
      console.log('üìÑ DashboardComponent: No hay contratos para procesar');
      return;
    }
    
    // Contratos cerrados (firmados)
    this.totalContratosCerrados = contratos.filter(contrato => 
      contrato.estado === 'firmado' || contrato.estado === 'completado'
    ).length;
    
    // Calcular tasa de conversi√≥n
    this.tasaConversion = this.totalCotizaciones > 0 ? 
      Math.round((this.totalContratosCerrados / this.totalCotizaciones) * 100) : 0;
    
    console.log('üìÑ DashboardComponent: M√©tricas de contratos calculadas:', {
      totalContratos: contratos.length,
      contratosCerrados: this.totalContratosCerrados,
      tasaConversion: this.tasaConversion
    });
  }
  
  /**
   * Procesa datos para el gr√°fico de rendimiento por usuario
   */
  private procesarRendimientoUsuarios(cotizaciones: any[]): void {
    if (!cotizaciones || cotizaciones.length === 0) {
      this.rendimientoUsuarios = [];
      return;
    }
    
    // Agrupar cotizaciones por atendedor
    const usuariosPorCotizaciones = cotizaciones.reduce((acc, cotizacion) => {
      const atendedor = cotizacion.atendido || 'Sin asignar';
      acc[atendedor] = (acc[atendedor] || 0) + 1;
      return acc;
    }, {} as any);
    
    // Convertir a array y ordenar por cantidad
    this.rendimientoUsuarios = Object.entries(usuariosPorCotizaciones)
      .map(([usuario, cantidad]) => ({
        usuario,
        cantidad: cantidad as number,
        porcentaje: Math.round(((cantidad as number) / cotizaciones.length) * 100)
      }))
      .sort((a, b) => b.cantidad - a.cantidad)
      .slice(0, 5); // Top 5 usuarios
    
    console.log('üë• DashboardComponent: Rendimiento por usuario calculado:', this.rendimientoUsuarios);
  }
  
  /**
   * Procesa datos para el gr√°fico de tendencia de ventas
   */
  private procesarTendenciaVentas(cotizaciones: any[]): void {
    if (!cotizaciones || cotizaciones.length === 0) {
      this.tendenciaVentas = [];
      return;
    }
    
    // Obtener √∫ltimos 6 meses
    const meses = [];
    const fechaActual = new Date();
    
    for (let i = 5; i >= 0; i--) {
      const fecha = new Date(fechaActual.getFullYear(), fechaActual.getMonth() - i, 1);
      const mes = fecha.toLocaleDateString('es-ES', { month: 'short' });
      meses.push({ mes, fecha });
    }
    
    // Contar cotizaciones por mes
    this.tendenciaVentas = meses.map(({ mes, fecha }) => {
      const cotizacionesMes = cotizaciones.filter(cotizacion => {
        const fechaCotizacion = cotizacion.fecha ? new Date(cotizacion.fecha) : new Date();
        return fechaCotizacion.getMonth() === fecha.getMonth() && 
               fechaCotizacion.getFullYear() === fecha.getFullYear();
      });
      
      return {
        mes,
        cotizaciones: cotizacionesMes.length,
        valor: cotizacionesMes.reduce((total, c) => total + (c.valorTotal || 0), 0)
      };
    });
    
    console.log('üìà DashboardComponent: Tendencia de ventas calculada:', this.tendenciaVentas);
  }
  
  /**
   * Procesa datos para el gr√°fico de embudo de ventas
   */
  private procesarEmbudoVentas(cotizaciones: any[]): void {
    if (!cotizaciones || cotizaciones.length === 0) {
      this.embudoVentas = [];
      return;
    }
    
    // Contar por estado
    const estados = cotizaciones.reduce((acc, cotizacion) => {
      const estado = cotizacion.estado || 'pendiente';
      acc[estado] = (acc[estado] || 0) + 1;
      return acc;
    }, {} as any);
    
    this.embudoVentas = Object.entries(estados).map(([estado, cantidad]) => ({
      estado: estado.charAt(0).toUpperCase() + estado.slice(1),
      cantidad: cantidad as number,
      porcentaje: Math.round(((cantidad as number) / cotizaciones.length) * 100)
    }));
    
    console.log('üéØ DashboardComponent: Embudo de ventas calculado:', this.embudoVentas);
  }
  
  /**
   * Formatea un valor num√©rico como moneda
   */
  formatearMoneda(valor: number): string {
    if (!valor || isNaN(valor)) return '$0';
    
    return new Intl.NumberFormat('es-CL', {
      style: 'currency',
      currency: 'CLP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(valor);
  }
  
  /**
   * Obtiene la altura del gr√°fico de barras basada en el valor m√°ximo
   */
  getBarHeight(cantidad: number): string {
    if (!this.rendimientoUsuarios || this.rendimientoUsuarios.length === 0) return '0%';
    
    const maxCantidad = Math.max(...this.rendimientoUsuarios.map(u => u.cantidad));
    const porcentaje = maxCantidad > 0 ? (cantidad / maxCantidad) * 100 : 0;
    return `${Math.max(porcentaje, 10)}%`; // M√≠nimo 10% para visibilidad
  }
  
  /**
   * Obtiene los valores para el eje Y del gr√°fico
   */
  getYAxisValues(): number[] {
    if (!this.rendimientoUsuarios || this.rendimientoUsuarios.length === 0) {
      return [0, 1, 2, 3, 4, 5];
    }
    
    const maxCantidad = Math.max(...this.rendimientoUsuarios.map(u => u.cantidad));
    const step = Math.ceil(maxCantidad / 5);
    const values = [];
    
    for (let i = 5; i >= 0; i--) {
      values.push(i * step);
    }
    
    return values;
  }
}
